# Simulation Kinematic For Scara Robot Printer

โปรเจคนี้มีวัตถุประสงค์เพื่อจำลองเส้นทางการเคลื่อนที่ของหัวพิมพ์ในเครื่องพิมพ์ 3 มิติแบบแขนกล SCARA (Selective Compliance Articulated Robot Arm) ซึ่งเป็นกลไกที่นิยมใช้ในระบบการพิมพ์ 3 มิติ เนื่องจากมีความสามารถในการเคลื่อนที่ในแนวระนาบอย่างรวดเร็วและแม่นยำ โดยโครงการนี้เน้นการศึกษาเชิงจลนศาสตร์ของการเคลื่อนที่ รวมถึงการคำนวณ Forward Kinematics (FK) เพื่อกำหนดตำแหน่งปลายทางของหัวพิมพ์และทิศทางการเคลื่อนที่ของข้อต่อต่าง ๆ ที่มีในระบบ SCARA
การจำลองนี้จะช่วยให้เข้าใจรูปแบบการเคลื่อนที่ของหัวพิมพ์ในระบบ SCARA และพฤติกรรมของแขนกลเมื่อเคลื่อนที่ไปตามเส้นทางที่กำหนด การศึกษานี้มีประโยชน์สำหรับการปรับปรุงกระบวนการพิมพ์ 3 มิติให้มีประสิทธิภาพและเพิ่มความแม่นยำในการควบคุมตำแหน่งของหัวพิมพ์ เพื่อให้สามารถผลิตชิ้นงานได้อย่างมีคุณภาพสูง
วิธีการดำเนินงานประกอบด้วยการพัฒนารูปแบบทางคณิตศาสตร์สำหรับการเคลื่อนที่ของหัวพิมพ์ SCARA โดยใช้สมการจลนศาสตร์ไปข้างหน้า (FK) และจลนศาสตร์ย้อนกลับ (IK) เพื่อสร้างแบบจำลองเส้นทางการเคลื่อนที่ พร้อมกับแสดงผลเส้นทางการเคลื่อนที่ในรูปแบบสามมิติ ซึ่งช่วยให้สามารถวิเคราะห์และปรับปรุงการเคลื่อนที่ของหัวพิมพ์ได้อย่างแม่นยำ

## บทที่ 1 บทนำ (Introduction)
### 1.1 จุดประสงค์โครงการ
1.	พัฒนาระบบจำลองการเคลื่อนที่ของหัวฉีด Scara 3D Printer เพื่อแสดงผลการเคลื่อนที่ในแนวระนาบ 3 มิติ ตามเส้นทางที่กำหนดจาก G-Code<br>
2.	เพื่อศึกษาการคำนวณจลนศาสตร์ไปข้างหน้า (Forward Kinematics) และจลนศาสตร์ย้อนกลับ (Inverse Kinematics) Scara 3D Printer เพื่อให้สามารถหาตำแหน่งปลายทางและการกำหนดทิศทางของข้อต่อได้อย่างแม่นยำ<br>
3.	พัฒนาอินเทอร์เฟซการแสดงผลเพื่อการตรวจสอบและวิเคราะห์การเคลื่อนที่ของหัวฉีด เพื่อให้สามารถวิเคราะห์เส้นทางการเคลื่อนที่และปรับปรุงประสิทธิภาพในการควบคุมการเคลื่อนที่ในอนาคต<br>

### 1.2	ขอบเขต
Toolbox สำหรับการคำนวณตำแหน่งปลาย (End Effector) ของระบบแขนกล Closed Loop Kinematic Chain ใน SCARA Robot
1. ศึกษาตำแหน่ง ความเร็ว ความเร่งของหุ่นยนต์ให้มีการเคลื่อนที่ที่มีความเร็วและความเร่งต่อเนื่องกัน โดยแสดงในรูปแบบปริภูมิ 2 มิติ
2. ศึกษาการเคลื่อนที่ของปลาย end efeector ในปริภูมิ 3 มิติ
   - การเคลื่อนที่ของแขนกลในแนวแกน X-Y
   - การเคลื่อนที่ในแนวแกน Z เพื่อควบคุมการขึ้นลง
3. แขนกลที่ใช้ศึกษาเป็น Scara Robot ที่เป็น RRP
4. Input ที่ใช้ในการคำนวณ
   - G-Code (Gn, X, Y, Z, F, E): ข้อมูลคำสั่งมาตรฐาน G-Code ที่กำหนดการเคลื่อนที่และคำสั่งต่าง ๆ ใช้ควบคุมการเคลื่อนที่ของหุ่นยนต์
   - ความยาว link ของแขนกล มวลของแขนกล (จาก CAD)
5. ศึกษา dynamic model เพื่อนำมาทำ visualization ด้วย MatLab

### 1.3 เนื้อหาในรายวิชาที่เกี่ยวข้อง
1)  Forward Kinematics
2)	Inverse Kinematics
3)	D-H Parameters
4)	Trajectory Planner
5)  Dynamic


### 1.4 ผลการศึกษาที่คาดหวัง
1)	ชิ้นงานหรือระบบที่คาดว่าจะได้จากโปรเจค
- ระบบจำลองเส้นทางการเคลื่อนที่ nozzle ของ 3D printer ประเภท Scara ตามคำสั่ง G-code โดยจะสามารถคำนวณตำแหน่งของ nozzle แต่ละจุด รวมถึงมุมของข้อต่อและความเร็วเชิงเส้น/เชิงมุมได้
- Dynamic Model แสดงการเคลื่อนที่ของ scara robot
2)	ความสามารถของชิ้นงานหรือระบบ
- ระบบสามารถแปลงคำสั่ง G-code เป็นเส้นทางการเคลื่อนที่ของหัวฉีดในแนวแกน x-y ของ SCARA robot ได้
- สามารถคำนวณตำแหน่งของหัวฉีด (end effector) และแสดงผลมุมของข้อต่อ เพื่อให้เห็นภาพรวมของการทำงานของระบบ

### 1.5 ผลการศึกษาที่คาดหวัง
![table](https://github.com/muigims/project_kinematics/blob/main/picture/table1.5.png)





## บทที่ 2 ทบทวนวรรณกรรม และ ทฤษฎีที่เกี่ยวข้อง (Literature Review)
### 2.1 ทฤษฎีที่เกี่ยวข้อง

#### 2.1.1	G-Code (Siamreprap. , 2017) [2]
G-Code (Geometric Code) เป็นภาษาที่ใช้ในการสั่งงานเครื่องจักร CNC (Computer Numerical Control) ซึ่งช่วยให้เครื่องจักรเคลื่อนที่ไปยังตำแหน่งที่ต้องการได้อย่างแม่นยำ รวมถึง 3d Printer ซึ่งเป็นเครื่องจักรที่ใช้ G-Code ในการควบคุมหัวพิมพ์ให้เคลื่อนที่ตามตำแหน่งที่กำหนดไว้ในไฟล์ G-Code ได้ด้วย
1. เลเยอร์และโครงสร้างที่พิมพ์
   LAYER:X: บอกว่าเครื่องพิมพ์กำลังพิมพ์อยู่ที่เลเยอร์ไหน เช่น เลเยอร์ที่ 1, 2, 3 เป็นต้น
   TYPE: บอกว่าเครื่องกำลังพิมพ์ส่วนไหนของชิ้นงาน:
   WALL-OUTER: ผนังด้านนอกของชิ้นงาน
   WALL-INNER: ผนังด้านในของชิ้นงาน
   SKIN: ผิวหน้าชิ้นงานที่เห็นได้
2. คำสั่งการเคลื่อนที่ของหัวพิมพ์
   G0: หัวพิมพ์เคลื่อนที่ไปยังตำแหน่งเป้าหมายแบบเร็ว โดยยังไม่ปล่อยพลาสติกออกมา
   G1: หัวพิมพ์เคลื่อนที่และพิมพ์พลาสติกไปพร้อมกัน
   ตัวอย่างข้อมูลเพิ่มเติมในคำสั่ง G1:
      X, Y: บอกตำแหน่งที่หัวพิมพ์จะเคลื่อนไป เช่น X=10, Y=20
   E: บอกปริมาณพลาสติกที่ปล่อยออกมาเพื่อสร้างชิ้นงาน
   F: บอกความเร็วที่หัวพิมพ์เคลื่อนที่ เช่น F=1500 หมายถึงเร็วมาก
3. การปรับความเร่ง
   SET_VELOCITY_LIMIT: ใช้กำหนดความเร่ง-ลดความเร่งของหัวพิมพ์
   ACCEL: กำหนดความเร่งสูงสุด เช่น ACCEL=1000 หมายถึงหัวพิมพ์สามารถเร่งความเร็วได้เร็วมาก
   ACCEL_TO_DECEL: กำหนดการลดความเร่ง เช่น ACCEL_TO_DECEL=500 เพื่อให้หัวพิมพ์ชะลอได้เนียนขึ้น
4. การควบคุมพัดลม
   M106 S255: เปิดพัดลมแรงสุด (S255 หมายถึง 100%)
   M106 S128: เปิดพัดลมครึ่งแรง (S128 หมายถึง 50%)
   M106 S0: ปิดพัดลม

#### 2.1.3 Path planning
การวางแผนเส้นทางคือการจัดลำดับการเคลื่อนที่ผ่านจุดต่าง ๆ (waypoints) ของหุ่นยนต์ โดยมีวัตถุประสงค์เพื่อลดระยะทางหรือเวลาที่ใช้ให้เกิดประสิทธิภาพสูงสุด การวางแผนนี้เกี่ยวข้องกับการคำนวณระยะทางระหว่างจุดทั้งหมดและการหาลำดับการเยี่ยมชมจุดที่เหมาะสมที่สุด ซึ่งในที่นี้สามารถทำได้ด้วยระยะทางแบบยุคลิด (Euclidean Distance) และอัลกอริธึม Linear Sum Assignment

ระยะทางแบบยุคลิดคำนวณจากสูตร

$$
d = \sqrt{(x_2 - x_1)^2 - (y_2 - y_1)^2}
$$

ซึ่งใช้สร้างเมทริกซ์ระยะทาง (Distance Matrix) ขนาด $n × n$ สำหรับจุดทั้งหมด  $n$ จุด โดย  $D[i][j]$ คือตำแหน่งที่ระบุระยะทางระหว่างจุด $i$ และ $j$ จากนั้น Linear Sum Assignment หรือที่รู้จักในชื่อ Hungarian Algorithm จะถูกใช้เพื่อลดค่ารวมของระยะทางทั้งหมดในเส้นทาง โดยให้จุดแต่ละจุดถูกจับคู่ได้เพียงครั้งเดียว

#### 2.1.4  Quintic Trajectory
Quintic Trajectory หรือพหุนามระดับ 5 ถูกออกแบบให้สมการประกอบด้วยพารามิเตอร์ตำแหน่ง ความเร็ว และความเร่ง โดยมีลักษณะดังนี้
สมการของ Quintic Trajectory

$$
q(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3 + a_4 t^4 + a_5 t^5
$$

จากสมการนี้สามารถคำนวณอนุพันธ์แรก (ความเร็ว) และอนุพันธ์ที่สอง (ความเร่ง) ได้ดังนี้

$$
\dot{q}(t) = a_1 + 2a_2 t + 3a_3 t^2 + 4a_4 t^3 + 5a_5 t^4
$$

$$
\ddot{q}(t) = 2a_2 + 6a_3 t + 12a_4 t^2 + 20a_5 t^3
$$

เมื่อแสดงเป็น matrix จะได้

$$
A =
\begin{bmatrix}
1 & 0 & 0 & 0 & 0 & 0 \\
0 & 1 & 0 & 0 & 0 & 0 \\
0 & 0 & 2 & 0 & 0 & 0 \\
1 & T & T^2 & T^3 & T^4 & T^5 \\
0 & 1 & 2T & 3T^2 & 4T^3 & 5T^4 \\
0 & 0 & 2 & 6T & 12T^2 & 20T^3
\end{bmatrix}
$$

จากนั้นทำการแก้สมการ ได้ดังนี้

$$
A \cdot a = b
$$

โดยที่
- $a$ คือ เมทริกซ์ของสัมประสิทธิ์ที่ได้จากเงื่อนไขขอบเขต
- $a$ คือ เวกเตอร์ของสัมประสิทธิ์ $a_0 , a_1 , a_2 , a_3 , a_4 , a_5$
- $b$ คือ เวกเตอร์ของค่าเงื่อนไขที่กำหนด (Boundary Values) $q(0)$ , $\dot{q}(0)$ , $\ddot{q}(0)$ , $q(T)$ , $\dot{q}(T)$ , $\ddot{q}(T)$

สมการ \(A \cdot a = b\) ใช้สำหรับการคำนวณหาค่าสัมประสิทธิ์ \(a_0, a_1, \dots, a_5\) จากเงื่อนไขขอบเขตที่กำหนดไว้ เพื่อสร้าง Quintic Trajectory ที่มีความราบรื่นและต่อเนื่องในตำแหน่ง ความเร็ว และความเร่ง.
Quintic Trajectory เป็นสมการที่ถูกเลือกใช้ในงานที่ต้องการความราบรื่นของการเคลื่อนที่ เช่น ระบบหุ่นยนต์ที่ต้องการให้ตำแหน่ง ความเร็ว และความเร่งเปลี่ยนแปลงอย่างราบรื่น เพื่อหลีกเลี่ยงการกระชากในระบบ

#### คุณสมบัติของ Quintic Trajectory
- สามารถควบคุมตำแหน่ง $q$ ความเร็ว $\dot{q}$ และความเร่ง $\ddot{q}$ ได้ที่จุดเริ่มต้น $t = 0$ และจุดสิ้นสุด $t = T$
- การเปลี่ยนแปลงความเร็วและความเร่งมีความต่อเนื่องตลอดเส้นทาง
- ใช้พารามิเตอร์ 6 ตัว (\(a_0\) ถึง \(a_5\)) เพื่อตอบสนองเงื่อนไขขอบเขต (Boundary Conditions) 6 ค่า



#### 2.1.5	Kinematic Calculations (Öğütülmüş, A. S., & Tınkır, M. , 2024) [1]
การวิเคราะห์ Kinematic คือการหาค่าทางจลศาสตร์ของแขนกล เช่น ตำแหน่ง ความเร็ว และความเร่ง เมื่อเวลาผ่านไป โดยอ้างอิงตามระบบพิกัดอ้างอิงหนึ่ง ๆ โดยไม่พิจารณาถึงแรงหรือโมเมนตัมที่ช่วยให้เกิดการเคลื่อนที่ ซึ่งเป็นขั้นตอนแรกสำหรับการวิเคราะห์ Kinematic ของแขนกล
การคำนวณ Kinematic ช่วยให้เราสร้างแบบจำลองทางคณิตศาสตร์ที่สามารถใช้ในการกำหนดแรงที่ต้องใช้กับข้อต่อต่าง ๆ ของแขนกล เพื่อให้แขนกลไปถึงตำแหน่งที่ต้องการในเวลาที่กำหนดได้
ที่เวลา T ใด ๆ ก็ตาม Forward Kinematics หมายถึงการคำนวณว่า เมื่อมีแรงกระทำในปริมาณที่แน่นอนต่อแขนกล แขนกลจะมีตำแหน่ง ความเร็ว และความเร่งเป็นเท่าใด ณ เวลานั้น ส่วน Inverse Kinematics หมายถึงการคำนวณว่าต้องใช้แรงเท่าใดที่ข้อต่อต่าง ๆ ของแขนกลเพื่อให้แขนกลย้ายจากตำแหน่งเริ่มต้นไปยังตำแหน่งที่ต้องการได้ (ดังรูปที่ 1)
การคำนวณ Forward และ Inverse Kinematics นี้ได้มาจากการวิเคราะห์เชิงวิเคราะห์ (Analytical Analysis) และสามารถแก้ไขได้โดยใช้สมการตรีโกณ <br>

![Kinematic Analysis Diagram](https://github.com/muigims/project_kinematics/blob/main/picture/Picture1.png)

**Forward Kinematics** <br>
การหาพิกัดของปลายแขนกล (End Effector) ของหุ่น Scara โดยใช้ความยาวของข้อต่อ $l_1$ และ $l_2$ (ดังรูปที่ 2) รวมถึงการฉายของแขนในแกนแนวตั้งและแนวนอน (X และ Y) สามารถคำนวณได้โดยใช้ความสัมพันธ์ทางตรีโกณมิติ ดังที่แสดงในสมการ

$$
X = L_1 \cos(\Theta) + L_2 \cos(\Theta + \Phi)
$$

$$
Y = L_1 \sin(\Theta) + L_2 \sin(\Theta + \Phi)
$$

โดยที่ $(\Theta)$ คือ มุมที่ข้อต่อแรกทำกับแนวนอน <br> 
     $(\Phi)$ คือ มุมที่ข้อต่อที่สองทำกับแนวนอน  <br>
![Position Of Arms](https://github.com/muigims/project_kinematics/blob/main/picture/Picture2.png)

**Inverse Kinematics** <br>
ในการวิเคราะห์การเคลื่อนที่ผกผัน (Inverse Kinematics) ของแขนกล Scara จุดประสงค์คือการหามุมที่ข้อต่อของแขนกลต้องหมุนเพื่อให้ปลายแขนกลหรือ end effector ไปถึงตำแหน่งที่ต้องการ ซึ่งในที่นี้คือจุด $P(x,y)$ บนแกน X และ Y ตามรูปที่ 3 
เริ่มจากการใช้กฎของโคไซน์กับสามเหลี่ยม $△EAO$ ซึ่งประกอบด้วยข้อต่อ $L_1$  และ $L_2$ โดยกำหนดให้ระยะห่างจากจุดศูนย์ถึงจุด $P$ มีค่าเท่ากับ $x^2+y^2$ เพื่อหามุม $\phi$ ซึ่งเป็นมุมระหว่างข้อต่อ $L_1$ และ $L_2$ เราสามารถคำนวณ $\cos\phi$ จากสมการ <br>

$$
X^2+Y^2=L_1^2+L_2^2+2L_1 L_2 \cos(/phi)
$$

โดยจัดรูปสมการจะได้ว่า

$$
\cos(\Phi) = \frac{X^2 + Y^2 - L_1^2 - L_2^2}{2 L_1 L_2}
$$

และคำนวณค่า $(\phi)$ ได้จาก 

$$
\Phi^{-1} = \cos^{-1} \left( \frac{X^2 + Y^2 - L_1^2 - L_2^2}{2 L_1 L_2} \right)
$$

เมื่อต้องการหาค่า $/sin(\phi)$ เพื่อใช้ในการคำนวณถัดไป เราสามารถใช้ความสัมพันธ์ทางตรีโกณมิติ $(\cos\phi)^2+(\sin\phi)^2=1$  ดังนั้นจะได้

$$
\sin(\phi)= √(1-(\cos\phi)^2 )
$$

หลังจากนั้นเราจะคำนวณมุม $\beta$ ซึ่งเป็นมุมระหว่างข้อต่อ $L_1$ กับเส้นตรงที่เชื่อมระหว่างจุดศูนย์กลางกับปลายแขน โดยใช้ความสัมพันธ์

$$
\tan(\beta) = \frac{L_2 \sin(\Phi)}{L_1 + L_2 \cos(\Phi)}
$$

และจากนั้นแก้สมการเพื่อหามุม $\beta$

$$
\beta = \tan^{-1} \left( \frac{L_2 \sin(\Phi)}{L_1 + L_2 \cos(\Phi)} \right)
$$

เมื่อได้มุม $\beta$ แล้ว เราจะสามารถคำนวณหามุม $Θ$ ซึ่งเป็นมุมที่ข้อต่อแรกต้องหมุนเพื่อให้แขนกลไปถึง $P(x,y)$ โดยใช้สมการ

$$
\tan (\beta+\theta)=Y/X
$$

ดังนั้นจะได้ว่า

$$
\theta = (\tan ^-1)  {Y}/{X-Β}
$$

ในกรณีของแขนกล Scara สามารถมีตำแหน่งปลายแขนที่เหมือนกันในมุมข้อต่อต่างกันสองตำแหน่ง ซึ่งในรูปที่ 3 แสดงตำแหน่ง "ซ้าย" และ "ขวา" ของแขนกลที่สามารถไปถึงจุดเดียวกันได้ การเลือกมุมของข้อต่อควรพิจารณาเงื่อนไขและข้อกำหนดของระบบเพื่อหลีกเลี่ยงปัญหาการเกิด Singularity ที่อาจเกิดขึ้นระหว่างการเคลื่อนที่ <br>
![Different Positions Of Scara Arms](https://github.com/muigims/project_kinematics/blob/main/picture/Picture3.png)

#### 2.1.6	Dynamic Analysis
การวิเคราะห์ทางพลศาสตร์ (Dynamic Analysis) ของแขนกลมีหลายวิธี เช่น วิธี Lagrange-Euler $(L-E)$, Recursive Lagrange $(R-L)$, Newton-Euler $(N-E)$ และ Generalized D’alembert $(G-D)$ ในการศึกษานี้ เลือกใช้วิธี Lagrange-Euler เนื่องจากมีความเป็นระบบและนำไปใช้ได้ง่ายเมื่อเทียบกับวิธีอื่น ๆ โดยวิธีนี้ใช้พลังงานรวมและงานที่เกิดขึ้นในระบบเป็นตัวแทน ในวิธี Lagrange-Euler ค่าของ $L$ จะถูกนิยามเป็น $L=K-P$ โดยที่ $K$ คือพลังงานจลน์ และ $P$ คือพลังงานศักย์ในระบบ
สมการ Lagrange-Euler คือ

$$
\begin{equation}
\frac{d}{dt} \left( \frac{\partial L}{\partial \dot{q}_i} \right) - \frac{\partial L}{\partial q_i} = Q_i, \quad i = 1, 2, \dots, n
\end{equation}
$$

โดยที่ $Q$ คือเวกเตอร์ของมุมข้อต่อ (Generalized Coordinates) ดังนี้

$$
\begin{equation}
q = \begin{bmatrix}
\theta_1 \\
\theta_2
\end{bmatrix}^T
\end{equation}
$$

และ $Q$ คือ Generalized Force Vector ซึ่งในที่นี้แรงบิด (Torque) $τ$ ที่ข้อต่อถูกกำหนดเป็น

$$
\begin{equation}
\tau = \begin{bmatrix}
\tau_1 \\
\tau_2
\end{bmatrix}^T
\end{equation}
$$

การคำนวณพลังงานจลน์และพลังงานศักย์
สำหรับแขนกลข้อแรก (link1)
- 	พลังงานจลน์ $K_1$ มีค่า

   $$
   K_1=1/2 m_1 l_1^2 \dot{\theta_1^2}
   $$

- 	พลังงานศักย์ $P_1$ มีค่า

   $$
   P_1=m_1 gl_1  \sin⁡(\theta_1 )
   $$
   
สำหรับแขนกลข้อที่สอง
พิกัดในแนวแกน X และ Y ของข้อที่สองคือ

$$
x_2=l_1  \cos⁡(\theta_1 )+l_2  \cos⁡(\theta_1+\theta_2 )
$$

$$
y_2=l_1  \sin⁡(\theta_1 )+l_2  \sin⁡(\theta_1+\theta_2 )
$$

- 	พลังงานจลน์ $K_2$ มีค่า
  $$
 K_2 = \frac{1}{2} m_2 v_2^2 \left( \dot{x}_2^2 + \dot{y}_2^2 \right)
  $$

- 	พลังงานศักย์ $P_2$  มีค่า:

  $$
  P_2=m_1 gy_2
  $$

สมการ Lagrangian ของแขนกลทั้งระบบ
โดยนำพลังงานจลน์และพลังงานศักย์ทั้งหมดมาคำนวณ Lagrangian Function ได้ว่า

$$
L=K_1+K_2-P_1-P_2
$$

การหาค่าแรงบิด $(\tau)$
จากสมการ Lagrange-Euler แรงบิดที่ต้องใช้ที่แต่ละข้อต่อจะได้เป็น

$$
\tau_1 = \left( (M_1 + M_2) L_1^2 + M_2 L_2^2 + 2M_2 L_1 L_2 \cos(\theta_2) \right) \ddot{\theta}_1 + \left( M_2 L_2^2 + M_2 L_1 L_2 \cos(\theta_2) \right) \ddot{\theta}_2 - M_2 L_1 L_2 \left( 2\dot{\theta}_1 \dot{\Theta}_2 + \dot{\theta}_2^2 \right) \sin(\theta_2) + (M_1 + M_2) g L_1 \cos(\theta_1) + M_2 g L_2 \cos(\theta_1 + \theta_2)
$$

$$
\tau_2 = \left( m_2 l_2^2 + m_2 l_1 l_2 \cos(\theta_2) \right) \ddot{\theta}_1 + m_2 l_2^2 \ddot{\theta}_2 + m_2 l_1 l_2 \dot{\theta}_1^2 \sin(\theta_2) + m_2 g l_2 \cos(\theta_1 + \theta_2)
$$

สมการ Dynamics ของแขนกล

$$
M(q) \ddot{q} + V(q, \dot{q}) + G(q) = \tau
$$

โดยที่ $M(q)$ คือเมทริกซ์มวล (Inertia Matrix), $V(q,\dot{q})$ คือเวกเตอร์แรง Coriolis/Centripetal และ $G(q)$ คือเวกเตอร์แรงโน้มถ่วง







#### 2.2 งานวิจัยที่เกี่ยวข้องกับงาน 
งานวิจัยนี้มุ่งเน้นการออกแบบและทดลองสร้าง Scara Printer โดยทำการคำนวณหาค่าต่างๆ เพื่อวางแผนเส้นทางการเคลื่อนที่ของหัวพิมพ์ รวมถึงการวิเคราะห์เชิงจลนศาสตร์ (Kinematics) และพลศาสตร์ (Dynamics) ของเครื่องพิมพ์แบบ Scara ในขั้นตอนการออกแบบนั้นได้ดำเนินการคำนวณค่า Forward Kinematics และ Inverse Kinematics รวมถึงการวิเคราะห์ Dynamics และกำหนดสมการ Trajectory เพื่อหาทิศทางและตำแหน่งที่หัวพิมพ์ควรเคลื่อนที่ ซึ่งผลการคำนวณนี้แสดงออกมาในรูปของกราฟ <br>
![แสดง (A) Position (B) Velocity (C) Acceleration (D) Torque](https://github.com/muigims/project_kinematics/blob/main/picture/Picture4.png) <br>
กราฟในรูปที่ 4 แสดง (A) ตำแหน่ง (Position), (B) ความเร็ว (Velocity), (C) ความเร่ง (Acceleration), และ (D) แรงบิด (Torque) โดยใช้การแก้สมการการเคลื่อนที่แบบทีละขั้นด้วยการเพิ่มค่าเวลาทีละ 0.01 วินาที โดยใช้ซอฟต์แวร์ MATLAB สำหรับค่าตั้งต้นที่กำหนดคือ $t_0=0,t_f=10;q_0=0,q_f=\pi/6 ;(q_0 ) = 0q,(q_f ) =0$ ซึ่งได้แสดงกราฟแสดงตำแหน่ง ความเร็ว ความเร่ง และแรงบิดของแขนกลตัวที่ 1 และตัวที่ 2 
นอกจากนี้ งานวิจัยยังได้กำหนดคุณลักษณะทางเทคนิคของ Scara Printer<br>
![](https://github.com/muigims/project_kinematics/blob/main/picture/Picture5.png)<br>

และกำหนดขนาดของชิ้นงานปริซึมสองประเภท ได้แก่ ปริซึมสี่เหลี่ยมจัตุรัสและปริซึมสามเหลี่ยม<br>
![](https://github.com/muigims/project_kinematics/blob/main/picture/Picture6.png)<br>

จากนั้นจะได้ Simulation แสดงผลการเปรียบเทียบเส้นทางการเคลื่อนที่ที่คาดหวัง เส้นทางจากการจำลอง และเส้นทางจริงที่ได้จากการทดลอง โดยผลการจำลองจริงนี้ได้มาจากการคำนวณทางจลศาสตร์โดยอิงจากค่าเส้นทางที่ต้องการ และการวัดที่ทำบนชิ้นงานปริซึมสี่เหลี่ยมจัตุรัสและสามเหลี่ยมที่พิมพ์ในรูปแบบสามมิติ ดังรูป<br>
![](https://github.com/muigims/project_kinematics/blob/main/picture/Picture7.png)<br>

นอกจากนี้ ยังมีการติดตามตำแหน่งของแขนกลในขณะที่ติดตามเส้นทางรูปสี่เหลี่ยมและสามเหลี่ยม (โดยไม่พิจารณาแกน Z) เพื่อใช้ในการคำนวณข้อผิดพลาดและปรับปรุงการเคลื่อนที่ของเครื่องพิมพ์ในอนาคต <br>
![](https://github.com/muigims/project_kinematics/blob/main/picture/Picture8.png)<br>

## บทที่ 3 วิธีดำเนินงาน
### System Diagram
- Input
    - Parameter of Scara robot
    - G-code
- Kinematics Toolbox
- Output
    - Position / Velocity / Accerelary graph
### 3.1 Make CAD in Solidwork
เริ่มจากสร้างไฟล์ new_square.gcode สี่เหลี่ยมที่มีความกว้าง 5 mm ยาว 5 mm และสูง 1 mm ตามรูปด้านล่าง
![](https://github.com/muigims/project_kinematics/blob/main/picture/Picture9.png) <br>
หลังจากนั้นนำมาเข้าโปรแกรม slicer เพื่อให้ได้ file G-code ออกมา ซึ่งในไฟล์จะถูกแบ่งเป็นแต่ละ layer (แกน z) และบอกตำแหน่งตามแนวแกน x-y ซึ่งเมื่อ slice ออกมาแล้วจะเห็นเส้นทางการเคลื่อนที่ดังนี้  <br>
![layer1](https://github.com/muigims/project_kinematics/blob/main/picture/layer1.png)<br>
![layer3](https://github.com/muigims/project_kinematics/blob/main/picture/layer3.png)<br>
![layer5](https://github.com/muigims/project_kinematics/blob/main/picture/layer5.png)<br>

### 3.2 Reading G-code Files
ใช้ฟังก์ชัน separate_points_by_layers ในการอ่านไฟล์ G-code และแยกจุดตามชั้น (Layer) โดยโค้ดจะทำการเปิดไฟล์และอ่านทีละบรรทัด แล้วตรวจสอบว่าบรรทัดใดเริ่มต้นด้วย ;LAYER เพื่อระบุการเริ่มต้นของชั้นใหม่ จากนั้นดึงค่าพิกัด X และ Y จากคำสั่ง G0 หรือ G1
เก็บจุดที่ดึงได้ลงใน current_layer และเพิ่มหมายเลขชั้น (layer_number) หลังจากจบการอ่านไฟล์ จะรวบรวมจุดทั้งหมดและส่งกลับในรูปแบบของรายการ (list)

```
# Function to separate points into layers based on certain commands or comments
def separate_points_by_layers(gcode_file):
    layers_of_points = []
    with open(gcode_file, 'r') as file:
        current_layer = []
        layer_number = 0

        for line in file:
            # Check for commands or comments that indicate a new layer
            if line.startswith(';LAYER'):
                if current_layer:
                    for point in current_layer:
                        layers_of_points.append([point[0], point[1], layer_number])
                    current_layer = []
                    layer_number += 1

            # Extract X and Y coordinates from G0 or G1 commands
            if line.startswith(('G0', 'G1')):
                x = None
                y = None
                if 'X' in line:
                    x = float(line.split('X')[1].split()[0])
                if 'Y' in line:
                    y = float(line.split('Y')[1].split()[0])
                if x is not None or y is not None:
                    current_layer.append([x, y])

        # Append the remaining points from the last layer
        for point in current_layer:
            layers_of_points.append([point[0], point[1], layer_number])

    return layers_of_points
```

ซึ่งจะได้ผลลัพธ์ออกมาเป็นตำแหน่งในแนวแกน x,y,z ในระยะเวลาเท่ากัน

```
[[-2.0, 20.0, 0], [-2.0, 145.0, 0], [-1.7, 145.0, 0], [-1.7, 20.0, 0], [5.138, 6.4, 1], [4.92, 6.759, 1], [4.92, 11.908, 1], [5.012, 12.29, 1], [5.371, 12.508, 1], [10.52, 12.508, 1], [10.902, 12.416, 1], [11.12, 12.057, 1], [11.12, 6.908, 1], [11.028, 6.526, 1], [10.669, 6.308, 1], [5.52, 6.308, 1], [5.138, 6.4, 1], [5.52, 6.908, 1], [5.52, 11.908, 1], [10.52, 11.908, 1], [10.52, 6.908, 1], [5.52, 6.908, 1], [5.32, 6.809, 1], [5.32, 11.908, 1], [5.421, 12.108, 1], [10.52, 12.108, 1], [10.72, 12.007, 1], [10.72, 6.908, 1], [10.619, 6.708, 1], [5.52, 6.708, 1], [5.32, 6.809, 1], [4.859, 6.157, 1], [4.676, 6.372, 1], [4.56, 6.629, 1], [4.52, 6.908, 1], [4.52, 12.024, 1], [4.615, 12.333, 1], [4.769, 12.569, 1], [4.984, 12.752, 1], [5.241, 12.868, 1], [5.52, 12.908, 1], [10.636, 12.908, 1], [10.945, 12.813, 1], [11.181, 12.659, 1], [11.364, 12.444, 1], [11.48, 12.187, 1], [11.52, 11.908, 1], [11.52, 6.792, 1], [11.425, 6.483, 1], [11.271, 6.247, 1], [11.056, 6.064, 1], [10.799, 5.948, 1], [10.52, 5.908, 1], [5.404, 5.908, 1], [5.095, 6.003, 1], [4.859, 6.157, 1], [4.676, 6.372, 1], [4.56, 6.629, 1], [4.52, 6.908, 1], [4.52, 8.064, 1], [4.859, 6.157, 1], [5.934, 7.322, 1], [5.71, 7.098, 1], [10.33, 7.098, 1], [10.33, 11.718, 1], [5.71, 11.718, 1], [5.71, 7.098, 1], [6.1, 7.488, 1], [9.94, 7.488, 1], [9.94, 11.328, 1], [6.1, 11.328, 1], [6.1, 7.488, 1], [9.768, 7.66, 1], [9.84, 8.187, 1], [9.799, 8.187, 1], [9.24, 7.628, 1], [8.703, 7.628, 1], [9.799, 8.724, 1], [9.799, 9.262, 1], [8.165, 7.628, 1], [7.628, 7.628, 1], [9.799, 9.799, 1], [9.799, 10.337, 1], [7.09, 7.628, 1], [6.553, 7.628, 1], [9.799, 10.874, 1], [9.574, 11.187, 1], [6.24, 7.852, 1], [6.24, 8.389, 1], [9.037, 11.187, 1], [8.5, 11.187, 1], [6.24, 8.927, 1], [6.24, 9.464, 1], [7.962, 11.187, 1], [7.425, 11.187, 1], [6.24, 10.002, 1], [6.24, 10.539, 1], [6.887, 11.187, 1], [6.35, 11.187, 1], [6.24, 11.076, 1], [6.24, 11.076, 1], [6.2, 11.076, 1], [5.99, 7.378, 1], [5.72, 7.108, 1], [6.12, 7.108, 2], [7.919, 7.108, 2], [9.919, 7.108, 2], [10.32, 7.108, 2], [10.32, 11.708, 2], [9.919, 11.708, 2], [8.12, 11.708, 2], [6.12, 11.708, 2], [5.72, 11.708, 2], [5.72, 11.307, 2], [5.72, 9.508, 2], [5.72, 7.508, 2], [5.72, 7.108, 2], [6.13, 7.518, 2], [7.91, 7.518, 2], [9.91, 7.518, 2], [9.91, 11.298, 2], [8.129, 11.298, 2], [6.13, 11.298, 2], [6.13, 9.518, 2], [6.13, 7.518, 2], [6.279, 7.862, 2], [6.474, 7.667, 2], [7.04, 7.667, 2], [6.279, 8.428, 2], [6.279, 8.993, 2], [7.606, 7.667, 2], [8.172, 7.667, 2], [6.279, 9.559, 2], [6.279, 10.125, 2], [8.737, 7.667, 2], [9.303, 7.667, 2], [6.279, 10.69, 2], [6.388, 11.147, 2], [9.759, 7.776, 2], [9.759, 8.342, 2], [6.954, 11.147, 2], [7.52, 11.147, 2], [9.759, 8.908, 2], [9.759, 9.473, 2], [8.085, 11.147, 2], [8.651, 11.147, 2], [9.759, 10.039, 2], [9.759, 10.605, 2], [9.217, 11.147, 2], [9.217, 11.147, 2], [9.217, 11.008, 2], [5.99, 7.378, 2], [5.72, 7.108, 2], [6.12, 7.108, 3], [7.919, 7.108, 3], [9.919, 7.108, 3], [10.32, 7.108, 3], [10.32, 11.708, 3], [9.919, 11.708, 3], [8.12, 11.708, 3], [6.12, 11.708, 3], [5.72, 11.708, 3], [5.72, 11.307, 3], [5.72, 9.508, 3], [5.72, 7.508, 3], [5.72, 7.108, 3], [6.13, 7.518, 3], [7.91, 7.518, 3], [9.91, 7.518, 3], [9.91, 11.298, 3], [8.129, 11.298, 3], [6.13, 11.298, 3], [6.13, 9.518, 3], [6.13, 7.518, 3], [6.39, 7.778, 3], [9.62, 8.063, 3], [9.76, 8.063, 3], [9.364, 7.667, 3], [8.799, 7.667, 3], [9.76, 8.628, 3], [9.76, 9.194, 3], [8.233, 7.667, 3], [7.667, 7.667, 3], [9.76, 9.76, 3], [9.76, 10.325, 3], [7.102, 7.667, 3], [6.536, 7.667, 3], [9.76, 10.891, 3], [9.45, 11.147, 3], [6.279, 7.976, 3], [6.279, 8.542, 3], [8.884, 11.147, 3], [8.319, 11.147, 3], [6.279, 9.108, 3], [6.279, 9.673, 3], [7.753, 11.147, 3], [7.187, 11.147, 3], [6.279, 10.239, 3], [6.279, 10.805, 3], [6.622, 11.147, 3], [6.622, 11.147, 3], [6.622, 11.008, 3], [5.99, 7.378, 3], [5.72, 7.108, 3], [6.12, 7.108, 4], [7.919, 7.108, 4], [9.919, 7.108, 4], [10.32, 7.108, 4], [10.32, 7.508, 4], [10.32, 9.307, 4], [10.32, 11.307, 4], [10.32, 11.708, 4], [5.72, 11.708, 4], [5.72, 11.307, 4], [5.72, 9.508, 4], [5.72, 7.508, 4], [5.72, 7.108, 4], [6.13, 7.518, 4], [7.91, 7.518, 4], [9.91, 7.518, 4], [9.91, 9.298, 4], [9.91, 11.298, 4], [6.13, 11.298, 4], [6.13, 9.518, 4], [6.13, 7.518, 4], [6.279, 7.862, 4], [6.474, 7.667, 4], [7.04, 7.667, 4], [6.279, 8.428, 4], [6.279, 8.993, 4], [7.606, 7.667, 4], [8.172, 7.667, 4], [6.279, 9.559, 4], [6.279, 10.125, 4], [8.737, 7.667, 4], [9.303, 7.667, 4], [6.279, 10.69, 4], [6.388, 11.147, 4], [9.759, 7.776, 4], [9.759, 8.342, 4], [6.954, 11.147, 4], [7.52, 11.147, 4], [9.759, 8.908, 4], [9.759, 9.473, 4], [8.085, 11.147, 4], [8.651, 11.147, 4], [9.759, 10.039, 4], [9.759, 10.605, 4], [9.217, 11.147, 4], [9.217, 11.147, 4], [9.217, 11.008, 4], [5.99, 7.378, 4], [5.72, 7.108, 4], [6.12, 7.108, 5], [7.919, 7.108, 5], [9.919, 7.108, 5], [10.32, 7.108, 5], [10.32, 11.708, 5], [9.919, 11.708, 5], [8.12, 11.708, 5], [6.12, 11.708, 5], [5.72, 11.708, 5], [5.72, 11.307, 5], [5.72, 9.508, 5], [5.72, 7.508, 5], [5.72, 7.108, 5], [6.13, 7.518, 5], [7.91, 7.518, 5], [9.91, 7.518, 5], [9.91, 11.298, 5], [8.129, 11.298, 5], [6.13, 11.298, 5], [6.13, 9.518, 5], [6.13, 7.518, 5], [7.91, 7.518, 5], [8.13, 7.518, 5], [9.425, 7.727, 5], [9.7, 8.003, 5], [9.7, 8.568, 5], [8.859, 7.727, 5], [8.293, 7.727, 5], [9.7, 9.134, 5], [9.7, 9.7, 5], [7.727, 7.727, 5], [7.162, 7.727, 5], [9.7, 10.265, 5], [9.7, 10.831, 5], [6.596, 7.727, 5], [6.339, 8.036, 5], [9.39, 11.087, 5], [8.824, 11.087, 5], [6.339, 8.602, 5], [6.339, 9.168, 5], [8.259, 11.087, 5], [7.693, 11.087, 5], [6.339, 9.734, 5], [6.339, 10.299, 5], [7.127, 11.087, 5], [6.561, 11.087, 5], [6.339, 10.865, 5], [170.0, 200.0, 5], [5.0, 5.0, 5], [2.0, 218.0, 5]]
```

### 3.3 Path Planning 
ในขั้นตอนนี้เป็นการนำจุดที่อ่านได้จากฟังก์ชัน separate_points_by_layers มาทำการหาระยะทาง โดยใช้ Euclidean distance ในการหาระยะระหว่างจุด 2 จุดในพื้นที่ 3 มิติ 

```
# Function to calculate Euclidean distance
def calculate_distance(point1, point2):
    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

# Path planning function
def path_planning(layers_of_points):
    num_points = len(layers_of_points)
    distances = np.zeros((num_points, num_points))
    for i in range(num_points):
        for j in range(num_points):
            distances[i][j] = calculate_distance(layers_of_points[i], layers_of_points[j])

    row_ind, col_ind = linear_sum_assignment(distances)
    optimal_order = [layers_of_points[i] for i in col_ind]
    return optimal_order

# Path planning for the points
optimal_path = path_planning(layers_of_points)
```

ซึ่งจะได้ผลลัพธ์ออกมาเป็นดังนี้

```
[[-2.0, 20.0, 0], [-2.0, 145.0, 0], [-1.7, 145.0, 0], [-1.7, 20.0, 0], [5.138, 6.4, 1], [4.92, 6.759, 1], [4.92, 11.908, 1], [5.012, 12.29, 1], [5.371, 12.508, 1], [10.52, 12.508, 1], [10.902, 12.416, 1], [11.12, 12.057, 1], [11.12, 6.908, 1], [11.028, 6.526, 1], [10.669, 6.308, 1], [5.52, 6.308, 1], [5.138, 6.4, 1], [5.52, 6.908, 1], [5.52, 11.908, 1], [10.52, 11.908, 1], [10.52, 6.908, 1], [5.52, 6.908, 1], [5.32, 6.809, 1], [5.32, 11.908, 1], [5.421, 12.108, 1], [10.52, 12.108, 1], [10.72, 12.007, 1], [10.72, 6.908, 1], [10.619, 6.708, 1], [5.52, 6.708, 1], [5.32, 6.809, 1], [4.859, 6.157, 1], [4.676, 6.372, 1], [4.56, 6.629, 1], [4.52, 6.908, 1], [4.52, 12.024, 1], [4.615, 12.333, 1], [4.769, 12.569, 1], [4.984, 12.752, 1], [5.241, 12.868, 1], [5.52, 12.908, 1], [10.636, 12.908, 1], [10.945, 12.813, 1], [11.181, 12.659, 1], [11.364, 12.444, 1], [11.48, 12.187, 1], [11.52, 11.908, 1], [11.52, 6.792, 1], [11.425, 6.483, 1], [11.271, 6.247, 1], [11.056, 6.064, 1], [10.799, 5.948, 1], [10.52, 5.908, 1], [5.404, 5.908, 1], [5.095, 6.003, 1], [4.859, 6.157, 1], [4.676, 6.372, 1], [4.56, 6.629, 1], [4.52, 6.908, 1], [4.52, 8.064, 1], [4.859, 6.157, 1], [5.934, 7.322, 1], [5.71, 7.098, 1], [10.33, 7.098, 1], [10.33, 11.718, 1], [5.71, 11.718, 1], [5.71, 7.098, 1], [6.1, 7.488, 1], [9.94, 7.488, 1], [9.94, 11.328, 1], [6.1, 11.328, 1], [6.1, 7.488, 1], [9.768, 7.66, 1], [9.84, 8.187, 1], [9.799, 8.187, 1], [9.24, 7.628, 1], [8.703, 7.628, 1], [9.799, 8.724, 1], [9.799, 9.262, 1], [8.165, 7.628, 1], [7.628, 7.628, 1], [9.799, 9.799, 1], [9.799, 10.337, 1], [7.09, 7.628, 1], [6.553, 7.628, 1], [9.799, 10.874, 1], [9.574, 11.187, 1], [6.24, 7.852, 1], [6.24, 8.389, 1], [9.037, 11.187, 1], [8.5, 11.187, 1], [6.24, 8.927, 1], [6.24, 9.464, 1], [7.962, 11.187, 1], [7.425, 11.187, 1], [6.24, 10.002, 1], [6.24, 10.539, 1], [6.887, 11.187, 1], [6.35, 11.187, 1], [6.24, 11.076, 1], [6.24, 11.076, 1], [6.2, 11.076, 1], [5.99, 7.378, 1], [5.72, 7.108, 1], [6.12, 7.108, 2], [7.919, 7.108, 2], [9.919, 7.108, 2], [10.32, 7.108, 2], [10.32, 11.708, 2], [9.919, 11.708, 2], [8.12, 11.708, 2], [6.12, 11.708, 2], [5.72, 11.708, 2], [5.72, 11.307, 2], [5.72, 9.508, 2], [5.72, 7.508, 2], [5.72, 7.108, 2], [6.13, 7.518, 2], [7.91, 7.518, 2], [9.91, 7.518, 2], [9.91, 11.298, 2], [8.129, 11.298, 2], [6.13, 11.298, 2], [6.13, 9.518, 2], [6.13, 7.518, 2], [6.279, 7.862, 2], [6.474, 7.667, 2], [7.04, 7.667, 2], [6.279, 8.428, 2], [6.279, 8.993, 2], [7.606, 7.667, 2], [8.172, 7.667, 2], [6.279, 9.559, 2], [6.279, 10.125, 2], [8.737, 7.667, 2], [9.303, 7.667, 2], [6.279, 10.69, 2], [6.388, 11.147, 2], [9.759, 7.776, 2], [9.759, 8.342, 2], [6.954, 11.147, 2], [7.52, 11.147, 2], [9.759, 8.908, 2], [9.759, 9.473, 2], [8.085, 11.147, 2], [8.651, 11.147, 2], [9.759, 10.039, 2], [9.759, 10.605, 2], [9.217, 11.147, 2], [9.217, 11.147, 2], [9.217, 11.008, 2], [5.99, 7.378, 2], [5.72, 7.108, 2], [6.12, 7.108, 3], [7.919, 7.108, 3], [9.919, 7.108, 3], [10.32, 7.108, 3], [10.32, 11.708, 3], [9.919, 11.708, 3], [8.12, 11.708, 3], [6.12, 11.708, 3], [5.72, 11.708, 3], [5.72, 11.307, 3], [5.72, 9.508, 3], [5.72, 7.508, 3], [5.72, 7.108, 3], [6.13, 7.518, 3], [7.91, 7.518, 3], [9.91, 7.518, 3], [9.91, 11.298, 3], [8.129, 11.298, 3], [6.13, 11.298, 3], [6.13, 9.518, 3], [6.13, 7.518, 3], [6.39, 7.778, 3], [9.62, 8.063, 3], [9.76, 8.063, 3], [9.364, 7.667, 3], [8.799, 7.667, 3], [9.76, 8.628, 3], [9.76, 9.194, 3], [8.233, 7.667, 3], [7.667, 7.667, 3], [9.76, 9.76, 3], [9.76, 10.325, 3], [7.102, 7.667, 3], [6.536, 7.667, 3], [9.76, 10.891, 3], [9.45, 11.147, 3], [6.279, 7.976, 3], [6.279, 8.542, 3], [8.884, 11.147, 3], [8.319, 11.147, 3], [6.279, 9.108, 3], [6.279, 9.673, 3], [7.753, 11.147, 3], [7.187, 11.147, 3], [6.279, 10.239, 3], [6.279, 10.805, 3], [6.622, 11.147, 3], [6.622, 11.147, 3], [6.622, 11.008, 3], [5.99, 7.378, 3], [5.72, 7.108, 3], [6.12, 7.108, 4], [7.919, 7.108, 4], [9.919, 7.108, 4], [10.32, 7.108, 4], [10.32, 7.508, 4], [10.32, 9.307, 4], [10.32, 11.307, 4], [10.32, 11.708, 4], [5.72, 11.708, 4], [5.72, 11.307, 4], [5.72, 9.508, 4], [5.72, 7.508, 4], [5.72, 7.108, 4], [6.13, 7.518, 4], [7.91, 7.518, 4], [9.91, 7.518, 4], [9.91, 9.298, 4], [9.91, 11.298, 4], [6.13, 11.298, 4], [6.13, 9.518, 4], [6.13, 7.518, 4], [6.279, 7.862, 4], [6.474, 7.667, 4], [7.04, 7.667, 4], [6.279, 8.428, 4], [6.279, 8.993, 4], [7.606, 7.667, 4], [8.172, 7.667, 4], [6.279, 9.559, 4], [6.279, 10.125, 4], [8.737, 7.667, 4], [9.303, 7.667, 4], [6.279, 10.69, 4], [6.388, 11.147, 4], [9.759, 7.776, 4], [9.759, 8.342, 4], [6.954, 11.147, 4], [7.52, 11.147, 4], [9.759, 8.908, 4], [9.759, 9.473, 4], [8.085, 11.147, 4], [8.651, 11.147, 4], [9.759, 10.039, 4], [9.759, 10.605, 4], [9.217, 11.147, 4], [9.217, 11.147, 4], [9.217, 11.008, 4], [5.99, 7.378, 4], [5.72, 7.108, 4], [6.12, 7.108, 5], [7.919, 7.108, 5], [9.919, 7.108, 5], [10.32, 7.108, 5], [10.32, 11.708, 5], [9.919, 11.708, 5], [8.12, 11.708, 5], [6.12, 11.708, 5], [5.72, 11.708, 5], [5.72, 11.307, 5], [5.72, 9.508, 5], [5.72, 7.508, 5], [5.72, 7.108, 5], [6.13, 7.518, 5], [7.91, 7.518, 5], [9.91, 7.518, 5], [9.91, 11.298, 5], [8.129, 11.298, 5], [6.13, 11.298, 5], [6.13, 9.518, 5], [6.13, 7.518, 5], [7.91, 7.518, 5], [8.13, 7.518, 5], [9.425, 7.727, 5], [9.7, 8.003, 5], [9.7, 8.568, 5], [8.859, 7.727, 5], [8.293, 7.727, 5], [9.7, 9.134, 5], [9.7, 9.7, 5], [7.727, 7.727, 5], [7.162, 7.727, 5], [9.7, 10.265, 5], [9.7, 10.831, 5], [6.596, 7.727, 5], [6.339, 8.036, 5], [9.39, 11.087, 5], [8.824, 11.087, 5], [6.339, 8.602, 5], [6.339, 9.168, 5], [8.259, 11.087, 5], [7.693, 11.087, 5], [6.339, 9.734, 5], [6.339, 10.299, 5], [7.127, 11.087, 5], [6.561, 11.087, 5], [6.339, 10.865, 5], [170.0, 200.0, 5], [5.0, 5.0, 5], [2.0, 218.0, 5]]
```

### 3.4 Trajectory Generation
ในขั้นตอนนี้ ได้เลือกใช้ trajectory เป็น quintic trajectory เนื่องจากต้องการให้การเคลื่อนที่มีความเร็ว และความเร่งที่ต่อเนื่องกัน จากการทำอนุพันธ์ฟังก์ชัน สมการดีกรี 5 จึงเพียงพอกับการควบคุมทั้งความเร็วและความเร่งให้มีความต่อเนื่อง ตะทำการเขียนสมการ และกำหนดค่าเริ่มต้นต่าง ๆ เช่น ตำแหน่งเริ่มต้น และตำแหน่งสุดท้าย

```
# Quintic Trajectory Generation Function
def quintic_trajectory(start, end, T, dt=0.01):
    """
    Generates a quintic trajectory between start and end points.
    
    Parameters:
    - start: Starting point [x0, y0, z0]
    - end: Ending point [xf, yf, zf]
    - T: Total time to move from start to end
    - dt: Sampling time
    
    Returns:
    - trajectory: Array of points along the quintic trajectory
    """
    # Boundary conditions
    # Position
    x0, y0, z0 = start
    xf, yf, zf = end
    # Velocities and accelerations
    v0 = [0, 0, 0]
    vf = [0, 0, 0]
    a0 = [0, 0, 0]
    af = [0, 0, 0]

    # Time vector
    t = np.linspace(0, T, int(T/dt) + 1)

    # Initialize trajectory
    traj = np.zeros((len(t), 3))

    for i, axis in enumerate(['x', 'y', 'z']):
        # Coefficients for quintic polynomial
        # Using boundary conditions: p0, pf, v0, vf, a0, af
        # The quintic polynomial is: p(t) = a0 + a1*t + a2*t^2 + a3*t^3 + a4*t^4 + a5*t^5
        # We solve for coefficients based on boundary conditions
        A = np.array([
            [1, 0,    0,     0,      0,       0],
            [0, 1,    0,     0,      0,       0],
            [0, 0,    2,     0,      0,       0],
            [1, T, T**2, T**3,  T**4,   T**5],
            [0, 1,  2*T,  3*T**2,4*T**3, 5*T**4],
            [0, 0,    2,  6*T,   12*T**2,20*T**3]
        ])
        b = np.array([
            start[i],
            v0[i],
            a0[i],
            end[i],
            vf[i],
            af[i]
        ])
        coeffs = np.linalg.solve(A, b)
        # Compute position for each time step
        traj[:, i] = coeffs[0] + coeffs[1]*t + coeffs[2]*t**2 + coeffs[3]*t**3 + coeffs[4]*t**4 + coeffs[5]*t**5
    
    return traj
```

จากนั้นเมื่อได้ output ออกมาแล้วทำให้ได้ตำแหน่งในแกนต่าง ๆ เพื่อสร้างเส้นทางการเคลื่อนที่ทั้งหมดผ่าน waypoints หลายๆ จุดโดยเชื่อมต่อการเคลื่อนที่แต่ละ segment โดยมีเงื่อนไขว่าถ้าเป็น segment ที่ไม่ใช่ตัวแรก ให้ตัดจุดแรกเพื่อหลีกเลี่ยงการซ้ำจุด จากนั้นรวมเส้นทาง segment ทั้งหมดเข้าด้วยกันเป็นเส้นทางเต็ม (full_traj)

```
# Generate Quintic Trajectory for all segments
def generate_quintic_trajectory(optimal_path, T_segment=1.0, dt=0.01):
    """
    Generates a complete quintic trajectory through all waypoints.
    
    Parameters:
    - optimal_path: List of waypoints [[x, y, z], ...]
    - T_segment: Time allocated for each segment
    - dt: Sampling time
    
    Returns:
    - full_traj: Array of all trajectory points
    """
    full_traj = []
    num_waypoints = len(optimal_path)
    for i in range(num_waypoints - 1):
        start = optimal_path[i]
        end = optimal_path[i + 1]
        traj_segment = quintic_trajectory(start, end, T_segment, dt)
        if i > 0:
            # Avoid duplicating points at the waypoints
            traj_segment = traj_segment[1:]
        full_traj.append(traj_segment)
    full_traj = np.vstack(full_traj)
    return full_traj

# Generate the quintic trajectory with sampling time = 0.01
sampling_time = 0.01  # seconds
time_per_segment = 1.0  # Adjust as needed
trajectory_points = generate_quintic_trajectory(optimal_path, T_segment=time_per_segment, dt=sampling_time)

trajectory_x_coords = trajectory_points[:, 0]
trajectory_y_coords = trajectory_points[:, 1]
trajectory_z_coords = trajectory_points[:, 2]
```

ทำให้ได้ output 

```
[[ -2.          20.           0.        ]
 [ -2.          20.00123132   0.        ]
 [ -2.          20.0097024    0.        ]
 ...
 [  2.00023286 217.98346711   5.        ]
 [  2.00002955 217.99790182   5.        ]
 [  2.         218.           5.        ]]
```

จากการคำนวณทั้งหมด สามารถนำมา plot เป็นกราฟได้ดังนี้
```
# Plotting all graphs in one figure
fig = plt.figure(figsize=(18, 12))

# Graph 1: Points classified by layers
ax1 = fig.add_subplot(221, projection='3d')
ax1.scatter(x_coords, y_coords, z_coords, color='blue', label='Points')
ax1.set_xlabel('X')
ax1.set_ylabel('Y')
ax1.set_zlabel('Layer')
ax1.set_title('Points Classified by Layer in 3D')
ax1.legend()

# Graph 2: Optimal path through points
ax2 = fig.add_subplot(222, projection='3d')
ax2.scatter(x_coords, y_coords, z_coords, color='blue', label='Points')
ax2.plot(x_coords, y_coords, z_coords, color='red', linestyle='-', linewidth=1.5, label='Optimal Path')
ax2.set_xlabel('X')
ax2.set_ylabel('Y')
ax2.set_zlabel('Layer')
ax2.set_title('Optimal Path Through Points in 3D')
ax2.legend()

# Graph 3: Optimal path and quintic trajectory
ax3 = fig.add_subplot(223, projection='3d')
ax3.scatter(x_coords, y_coords, z_coords, color='blue', label='Points')
# ax3.plot(x_coords, y_coords, z_coords, color='red', linestyle='-', linewidth=1.5, label='Optimal Path')
ax3.plot(trajectory_x_coords, trajectory_y_coords, trajectory_z_coords, color='green', linestyle='-', linewidth=2, label='Quintic Trajectory')
ax3.set_xlabel('X')
ax3.set_ylabel('Y')
ax3.set_zlabel('Layer')
ax3.set_title('Optimal Path and Quintic Trajectory in 3D')
ax3.legend()

# Graph 4: Desired end-effector poses
ax4 = fig.add_subplot(224, projection='3d')
ax4.scatter(trajectory_x_coords, trajectory_y_coords, trajectory_z_coords, color='red', s=10, label='Desired Poses')
ax4.set_xlabel('X')
ax4.set_ylabel('Y')
ax4.set_zlabel('Z')
ax4.set_title('Desired End-Effector Poses')
ax4.legend()

# Adjust layout and show
plt.tight_layout()
plt.show()
```
![4praph](https://github.com/muigims/project_kinematics/blob/main/picture/4praph.png)

ทำให้สามารถดู
- กราฟที่ 1 คึอ จุดที่อ่านได้จาก G-code 
- กราฟที่ 2 คึอ Optimal path เอาจุดที่อ่านได้มาต่อการเป้นเส้นทางการเคลื่อนที่
- กราฟที่ 3 คึอ Quintic Trajectory เอาจุดที่ได้มาเข้าสมการ quintic trajectory แต่ในรูปนี้จะไม่ค่อยเห็นความแตกต่างมากนัก เนื่องจากจุดที่อ่านได้จาก G-code มีระยะที่ใกล้กันมาก เมื่อนำมา plot ในกราฟ 3D จึงไม่สามารถเห็นความแตกต่างได้
- กราฟที่ 4 คึอ End effector Pose คือตำแหน่งที่ end effector เคลื่อนที่ไป
### 3.5 Velocity and Acceleration Calculation

ในส่วนนี้ เราต้องการหาความเร็วของวัตถุในแต่ละช่วงเวลา ซึ่งทำได้โดยการคำนวณ อัตราการเปลี่ยนแปลงของตำแหน่ง (trajectory_points) ระหว่างจุดแต่ละจุด จากนั้นนำค่าที่ได้มาหารด้วยช่วงเวลาที่แต่ละจุดห่างกัน (sampling_time) เพื่อให้ได้ค่าความเร็วในหน่วยที่สัมพันธ์กับเวลา เมื่อได้ความเร็วมาแล้ว ต้องทำการหาความเร่ง ซึ่งก็คือ อัตราการเปลี่ยนแปลงของความเร็ว ในแต่ละช่วงเวลา ซึ่งสามารถคำนวณได้ดังนี้

```
# Velocity and Acceleration Calculations for Quintic Trajectory
velocity = np.diff(trajectory_points, axis=0) / sampling_time

# Calculate acceleration using numerical differentiation of velocity
acceleration = np.diff(velocity, axis=0) / sampling_time

# Create time vectors
time_total = trajectory_points.shape[0] * sampling_time
time = np.arange(0, trajectory_points.shape[0]) * sampling_time
time_velocity = time[:-1]
time_acceleration = time[:-2]
```

ความเร็วที่ได้

```
[[ 0.00000000e+00  1.23132500e-01  0.00000000e+00]
 [ 0.00000000e+00  8.47107500e-01  0.00000000e+00]
 [ 0.00000000e+00  2.25470750e+00  0.00000000e+00]
 ...
 [-5.41129800e-02  3.84202158e+00  0.00000000e+00]
 [-2.03305800e-02  1.44347118e+00  0.00000000e+00]
 [-2.95518000e-03  2.09817780e-01  0.00000000e+00]]
```

ความเร่งที่ได้

```
[[   0.           72.3975        0.        ]
 [   0.          140.76          0.        ]
 [   0.          204.8025        0.        ]
 ...
 [   4.91526    -348.98346       0.        ]
 [   3.37824    -239.85504001    0.        ]
 [   1.73754    -123.36534       0.        ]]
```
เมื่อนำมา plot กราฟจะได้ดังนี้

```
# Plot Position, Velocity, and Acceleration
fig, axs = plt.subplots(3, 1, figsize=(10, 12))

# Position
axs[0].plot(time, trajectory_points[:, 0], label='X Position', color='r')
axs[0].plot(time, trajectory_points[:, 1], label='Y Position', color='g')
axs[0].plot(time, trajectory_points[:, 2], label='Z Position', color='b')
axs[0].set_title('Position (X, Y, Z)')
axs[0].set_xlabel('Time [s]')
axs[0].set_ylabel('Position')
axs[0].legend()
axs[0].grid(True)

# Velocity
axs[1].plot(time_velocity, velocity[:, 0], label='X Velocity', color='r')
axs[1].plot(time_velocity, velocity[:, 1], label='Y Velocity', color='g')
axs[1].plot(time_velocity, velocity[:, 2], label='Z Velocity', color='b')
axs[1].set_title('Velocity (X, Y, Z)')
axs[1].set_xlabel('Time [s]')
axs[1].set_ylabel('Velocity')
axs[1].legend()
axs[1].grid(True)

# Acceleration
axs[2].plot(time_acceleration, acceleration[:, 0], label='X Acceleration', color='r')
axs[2].plot(time_acceleration, acceleration[:, 1], label='Y Acceleration', color='g')
axs[2].plot(time_acceleration, acceleration[:, 2], label='Z Acceleration', color='b')
axs[2].set_title('Acceleration (X, Y, Z)')
axs[2].set_xlabel('Time [s]')
axs[2].set_ylabel('Acceleration')
axs[2].legend()
axs[2].grid(True)

# Adjust layout and show
plt.tight_layout()
plt.show()
```

![p_v_s_graph](https://github.com/muigims/project_kinematics/blob/main/picture/p_v_s_graph.png) <br>
กราฟนี้แสดงถึงตำแหน่ง ความเร็ว ความเร่งของแต่ละแกน ในระนาบ 2 มิติ ซึ่งต้องการ plot เพื่อดูว่า ความเร็วและความเร่งมีความต่อเนื่องกันหรือไม่ ซึ่งเมื่อซูมเข้าไปจะเห็นได้ว่าความเร็ว ความเร่ง มีความต่อเนื่องกันตามที่ต้องการ <br>
![p_v_s_zoom](https://github.com/muigims/project_kinematics/blob/main/picture/p_v_s_zoom.png) <br>
จากนั้นนำ trajectory ที่ได้มา plot เป้น animation <br>
![animation](https://github.com/muigims/project_kinematics/blob/main/picture/animation.mp4) <br>
### 3.6 Inverse Kinematics
ในขั้นตอนนี้ ได้มีการกำหนดความยาวของแขนกลเป็น $L_1$ และ $L_2$ ให้มีค่าเท่ากับ 320 mm เพื่อนำค่าตำแหน่งที่อ่านได้จาก trajectory ในรูปแบบของ $x,y,z$ มาคำนวณ โดยได้มีการปรับค่าเพื่อชดเชย offset ตำแหน่งเริ่มต้นของหุ่นยนต์ โดยป้องกันไม่ให้หุ่นยนต์เกิดภาวะ Singularity 

โดยในการคำนวณ Inverse Kinematics เริ่มจากต้องคำนวรระยะ $r^2 = x^2 + y^2$ เพื่อใช้หามุม $q_2$ จากนั้นเมื่อสามารถคำนวณหาค่า $q_2$ ได้แแล้วจะใช้ Law of Cosines ในการคำนวณหา $q_1$ ต่อ และส่วน $q_3$ จะใช้ค่า $z$ โดยตรงจาก trajectory เนื่องจากข้อต่อนี้เป็นข้อต่อแบบ prismatic เมื่อคำนวณครบทุกจุดแล้ว ข้อมูลทั้งหมดจะถูกนำมาบันทึกลงในตาราง โดยเพิ่มคอลัมน์เวลา $t$ ซึ่งกำหนดช่วงเวลาเป็น 0.01 วินาทีต่อจุด และจัดเก็บข้อมูลทั้งหมดลงในไฟล์ CSV ชื่อ q.csv 

ซึ่งในโค้ดมีการกำหนดเงื่อนไขในการคำนวณ IK โดยมีเงื่อนไขสำคัญที่ต้องตรวจสอบ คือค่า $cos(q_2)​$ ต้องอยู่ในช่วงที่เป็นไปได้ [−1,1] หากอยู่นอกช่วงนี้จะหมายถึงตำแหน่งที่กำหนดไม่สามารถแก้สมการได้ โค้ดจะข้ามจุดนั้นไปโดยไม่บันทึกค่ามุม 

```
import numpy as np
import matplotlib.pyplot as plt
import pandas as pd

# กำหนดความยาวของแขน
L1 = 320  # mm
L2 = 320  # mm


trajectory_x_coords = trajectory_points[:, 0]
trajectory_y_coords = trajectory_points[:, 1]
trajectory_z_coords = trajectory_points[:, 2]

trajectory_x_coords = trajectory_x_coords + 320
trajectory_y_coords = trajectory_y_coords + 320


# ฟังก์ชันสำหรับคำนวณ inverse kinematics
def inverse_kinematics(x, y, z):
    r_squared = x**2 + y**2
    cos_q2 = (r_squared - L1**2 - L2**2) / (2 * L1 * L2)
    
    if cos_q2 < -1 or cos_q2 > 1:
        return None, None, None
    
    q2 = np.arccos(cos_q2)
    k1 = L1 + L2 * np.cos(q2)
    k2 = L2 * np.sin(q2)
    q1 = np.arctan2(y, x) - np.arctan2(k2, k1)
    q3 = z
    
    return np.degrees(q1), np.degrees(q2), q3

# สร้าง lists สำหรับเก็บค่า q1, q2, q3
q1_values = []
q2_values = []
q3_values = []

# คำนวณค่า q1, q2, q3
for x, y, z in zip(trajectory_x_coords, trajectory_y_coords, trajectory_z_coords):
    q1, q2, q3 = inverse_kinematics(x, y, z)
    if q1 is not None:
        q1_values.append(q1)
        q2_values.append(q2)
        q3_values.append(q3)

# แสดงผลลัพธ์
print(f"Generated {len(q1_values)} trajectory points at 0.01-second intervals.")

# บันทึกข้อมูลเป็น .csv
joint_angles_df = pd.DataFrame({
    'Time (s)': np.arange(len(q1_values)) * 0.01,
    'q1_values_deg': q1_values,
    'q2_values_deg': q2_values,
    'q3_values_mm': q3_values
})
joint_angles_df.to_csv('q.csv', index=False)
print("Saved interpolated joint angles to 'q.csv'")
```
ผลลัพธ์ที่ได้
```
Generated 30124 trajectory points at 0.01-second intervals.
```

![csv_q](https://github.com/muigims/project_kinematics/blob/main/picture/csv_q.png)

เมื่อนำมา plot กราฟเมื่อให้ดูการกระจายตัวของค่า q จะเห็นได้ว่าค่า $q_1,q_2$ มีการเปลี่ยนแปลงมากในช่วงแรกและช่วงปลายตามตำแหน่งที่อ่านได้จาก g-code ส่วน $q_3$ มีการเปลี่ยนแปลง 5 ครั้ง ตามจำนวน layer ของ CAD ที่วาดไว้
![q_plot](https://github.com/muigims/project_kinematics/blob/main/picture/q_plot.png)

### 3.7 Dynamic Calculation

หลังจากที่ได้ค่า $q_1,q_2$ มาแล้วนั้น ได้มีการกำหนดค่าคงที่ต่าง ๆ ที่ได้จากการไฟล์ URDF ซึ่งมีการกำหนด material และ axis ต่าง ๆ เพื่อให้ได้ค่าคงที่ เช่น moment of inertia , mass รวมทั้งได้ค่า $\dot{q_1},\dot{q_2},\ddot{q_1},\ddot{q_2}$ ต้องทำการเปลี่ยนหน่วยจาก degree เป็น radian โดยเมื่อเข้าสมการแล้วจะทำให้ได้ค่า $\tau_1$ , $\tau_2$ หลังจากคำนวณเสร็จแล้วจะทำการบันทึกค่าไว้ในไฟล์ CSV ชื่อ q_with_derivatives_and_torque.csv ซึ่งในขั้นตอนนี้จะเป็นการคำนวณแค่ค่า $q_1,q_2$ ตาม Papers ที่แนบไว้ เนื่องจาก $q_3$ เป็น Prismatics Joint จึงไม่ต้องคำนวณแรงบิดที่เกิดขึ้น

```
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# กำหนดมวล (kg)
m_base = 13.521
m_link1 = 15.936
m_link2 = 13.373
m_shaft = 0.80683
# กำหนดความเฉื่อย (kg·m²)
I_base = np.array([
    [0.07366, 2.366E-19, -3.8224E-18],
    [2.366E-19, 0.08182, -0.0035749],
    [-3.8224E-18, -0.0035749, 0.056323]
])
I_link1 = np.array([
    [0.069528, -0.0021755, -0.059062],
    [-0.0021755, 0.26893, -0.00064495],
    [-0.059062, -0.00064495, 0.24013]
])
I_link2 = np.array([
    [0.060294, -6.133E-05, -0.049853],
    [-6.133E-05, 0.25254, -1.6152E-05],
    [-0.049853, -1.6152E-05, 0.21224]
])
I_shaft = np.array([
    [0.012728, 2.1641E-20, 6.244E-19],
    [2.1641E-20, 0.012728, 7.3305E-20],
    [6.244E-19, 7.3305E-20, 0.00015918]
])
# กำหนดค่า g (ความเร่งโน้มถ่วง)
g = 9.81  # m/s²
# อ่านข้อมูลจาก .csv
joint_angles_df = pd.read_csv('q_with_derivatives.csv')
# แปลงค่าจาก degrees เป็น radians สำหรับ q1 และ q2 ถ้าจำเป็น
joint_angles_df['q1_values_rad'] = np.deg2rad(joint_angles_df['q1_values_deg'])
joint_angles_df['q2_values_rad'] = np.deg2rad(joint_angles_df['q2_values_deg'])
# กำหนดตำแหน่งข้อต่อ (radians สำหรับ revolute, meters สำหรับ prismatic)
q1_values = joint_angles_df['q1_values_rad'].values       # radians
q2_values = joint_angles_df['q2_values_rad'].values       # radians
# ความเร็วของข้อต่อ
q1_dot_values = np.deg2rad(joint_angles_df['q1_dot_deg_per_s'].values)      # rad/s
q2_dot_values = np.deg2rad(joint_angles_df['q2_dot_deg_per_s'].values)      # rad/s
# การเร่งของข้อต่อ
q1_dotdot_values = np.deg2rad(joint_angles_df['q1_dotdot_deg_per_s2'].values)  # rad/s²
q2_dotdot_values = np.deg2rad(joint_angles_df['q2_dotdot_deg_per_s2'].values)  # rad/s²
# สร้างฟังก์ชันเพื่อคำนวณ Torque สำหรับชุดค่าเฉพาะ
def calculate_torque(q1, q2, q1_dot, q2_dot, q1_dotdot, q2_dotdot):
    # คำนวณ Mass Matrix
    a = I_link1[0, 0] + I_link2[0, 0] + I_shaft[0, 0] + m_link1 * (0.094352**2 + 0.0010294**2) + m_link2 * (0.19698**2 + 6.5485E-05**2)
    b = I_link2[0, 0] + I_shaft[0, 0] + m_link2 * (0.19698**2 + 6.5485E-05**2)
    M = np.array([
        [a + 2 * b * np.cos(q2), b * np.cos(q2)],
        [b * np.cos(q2), b]
    ])
    # คำนวณ Coriolis and Centrifugal Forces
    C = np.array([
        [-b * np.sin(q2) * q2_dot, -b * np.sin(q2) * (q1_dot + q2_dot)],
        [b * np.sin(q2) * q1_dot, 0],
    ])
    Cq_dot = C @ np.array([q1_dot, q2_dot])
    # คำนวณ Gravitational Forces
    G1 = m_base * g * 0.097334 + m_link1 * g * 0.12084 + m_link2 * g * 0.083139
    G2 = m_link1 * g * 0.12084 + m_link2 * g * 0.083139
    G = np.array([G1, G2])
    # Joint Accelerations
    q_ddot = np.array([q1_dotdot, q2_dotdot])
    # คำนวณ Torque
    tau = M @ q_ddot + Cq_dot + G
    return tau
# คำนวณ Torque สำหรับแต่ละชุดค่า
torques = []
for i in range(len(q1_values)):
    tau = calculate_torque(
        q1_values[i], q2_values[i],
        q1_dot_values[i], q2_dot_values[i],
        q1_dotdot_values[i], q2_dotdot_values[i]
    )
    torques.append(tau)

# แปลงเป็น numpy array
torques = np.array(torques)

# เพิ่มค่า Torque ลงใน DataFrame
joint_angles_df['tau1'] = torques[:, 0]
joint_angles_df['tau2'] = torques[:, 1]

# บันทึกข้อมูลเป็น .csv
joint_angles_df.to_csv('q_with_derivatives_and_torque.csv', index=False)
print("Saved joint angles, velocities, accelerations, and torques to 'q_with_derivatives_and_torque.csv'")

```
เมื่อนำค่าที่ได้มา plot เป็นกราฟจะได้ดังนี้<br>
![graph_torque](https://github.com/muigims/project_kinematics/blob/main/picture/graph_torque.png) <br>

เนื่องจากจากไฟล์ที่อ่านได้มีระยะเวลาที่นานกว่า เมื่อplot กราฟ torque เทียบกับเวลาจึงไม่เห็นการเปลี่ยนแปลงมาก แต่เทมื่อซูมเข้าไปจะทำให้เห็นการเปลี่ยบนแปลงที่มากขึ้น<br>
![zoom_graph_torque](https://github.com/muigims/project_kinematics/blob/main/picture/zoom_graph_torque.png) <br>


### 3.8 Dynamic Model
ในขั้นตอนนี้จะทำการ import ไฟล์ q.csv เข้าสู่ Matlab โดยทำการเพิ่มเข้าสู่ workspace <br>
![immport_q](https://github.com/muigims/project_kinematics/blob/main/picture/immport_q.png) <br>
จากนั้นทำการ spit ค่าต่าง ๆ ในไฟล์ ให้อยู่แยกกันใน workspace เพื่อให้ง่ายต่อการดึงมาใช้ โดยมีขั้นตอนดังนี้

```
% ดึงค่า q1_values_deg, q2_values_deg, q3_values_mm จากตาราง jointangles
time = q.Times;
q1_values_deg = q.q1_values_deg;
q2_values_deg = q.q2_values_deg;
q3_values_mm = q.q3_values_mm;

% สร้างข้อมูลให้เป็น matrix ที่มีเวลาเป็นคอลัมน์แรกและ q1_input, q2_input, q3_input เป็นคอลัมน์ที่สอง
q1_data = [time, q1_values_deg];  % q1 เทียบเวลา
q2_data = [time, q2_values_deg];  % q2 เทียบเวลา
q3_data = [time, q3_values_mm];   % q3 เทียบเวลา

% ส่งข้อมูลไปยัง workspace
assignin('base', 'q1_input_data', q1_data);
assignin('base', 'q2_input_data', q2_data);
assignin('base', 'q3_input_data', q3_data);
```

ซึ่งจะได้ผลลัพธ์ใน workspace ตามในภาพด้านขวา<br>
![spitq](https://github.com/muigims/project_kinematics/blob/main/picture/spit_q.png) <br>
จากนั้นทำการดึงข้อมูล .urdf ที่เราได้จากการวาด CAD จากโปรแกรม solidwork โดยภาพ scara robot ของเรามีหน้าตาดังนี้<br>
![cad](https://github.com/muigims/project_kinematics/blob/main/picture/cad.png) <br>
ซึ่งเมื่อมาวิเคราะห์และทำตาราง MDH-Parameter จะได้ดังนี้<br>
![mdh](https://github.com/muigims/project_kinematics/blob/main/picture/mdh.png) <br>
โดยในไฟล์ .urdf ที่ได้เมื่อกำหนด materials,point,axis จะทำให้ได้ต่าง ๆ ออกมาดังนี้<br>
![parameter_urdf](https://github.com/muigims/project_kinematics/blob/main/picture/parameter_urdf.png) <br>
รูปภาพการกำหนดแกนของหุ่น scara robot <br>
![axis](https://github.com/muigims/project_kinematics/blob/main/picture/axis.png) <br>
จากนั้นทำการ import .urdf ของ scara robot เข้าสู่ mmatlab จะได้ภาพรวม model ดังนี้ <br>
![import_scara](https://github.com/muigims/project_kinematics/blob/main/picture/import_scara.png) <br>
จากนั้นทำการตั้งค่า limit ของแต่ละ joint (สามารถตั้งค่า limit ได้ตั้งแต่ใน solidwork) ซึ่งมีการกำหนด limit ต่าง ๆ ดังนี้ <br>
![limit_q1](https://github.com/muigims/project_kinematics/blob/main/picture/limit_q1.png)<br>
![limit_q2](https://github.com/muigims/project_kinematics/blob/main/picture/limit_q2.png)<br>
![limit_q3](https://github.com/muigims/project_kinematics/blob/main/picture/limit_q3.png)<br>

จากนั้นทำการดึงค่า $q_1,q_2,q_3$ เพื่อทำการป้อนเป็น input ของ model จากนั้นให้เลือก output ขงอ ทodel เป็นค่า $\tau$ ดังนี้
![dynamic_model](https://github.com/muigims/project_kinematics/blob/main/picture/dynamic_model.png)

ต่อในมาขั้นตอนนี้เพื่อทำการ Recheck ว่า scara robot ของเราสามารถเคลื่อนที่ตามจุดที่กำหนดได้หรือไม่ และมีการเปลี่ยนแปลงของ Torque ที่ถูกต้องหรือไม่ จึงได้ทำการกำหนดจุด Via point ขึ้นมาเพื่อดูพฤติกรรมของ scara robot และนำมาดู Simulation และกราฟ Torque ที่เกิดขึ้น เนื่องจากข้อจำกัดทางด้าน G-code เพราะหากต้องการให้หุ่นยนต์เคลื่อนที่ในพื้นที่วงกว้าง จะต้องใช้ไฟล์ขนาดใหญ่และใช้เวลานานในการรัน เนื่องจากในไฟล์ G-code จะมีการกำหนดจุดหลายจุด จึงได้ำกหนดจุดขึ้นมาเพื่อให้ดูพฤติกรรมการเคลื่อนที่และแรงบิดได้ง่ายขึ้น
#วีดีโอ
จากวีดีโอจะเห็นได้ว่าจากตำแหน่งที่กำหนดในภาพด้านซ้าย หุ่นยนต์มีการเคลื่อนที่ตามจุดที่กำหนดได้อย่างถูกต้อง และแรงบิดที่เกิดขึ้นใน Joint ที่ 1 และ 2 มีความสอดคล้องกับเส้นทางการเคลื่อนที่ตามคลิปวีดีโอ 

## บทที่ 4 ผลการศึกษา
### 4.1 Optimal Path & Trajectory 
จากการศึกษา Optimal Path & Trajectory เมื่อ plot กราฟออกมาดูตามรูปด้านล่างนี้ 
# รูป
จะเห็นได้ว่ากราฟทั้ง 4 กราฟมีตำแหน่งของจุดที่ตำแหน่งเดียวกัน โดยภาพแรกคือ จุดที่อ่านว่าได้จาก G-code ทั้งหมด ซึ่งยังไม่ผ่านการคิดหาเส้นทางการเคลื่อนที่ ภาพที่ 2 คือ เส้นทางการเคลื่อนที่ที่เอาจุดจากกราฟที่ 1 มาเรียงต่อกัน ภาพที่ 3 คือ กราฟที่แสดงเส้นทางการเคลื่อนที่หลังจากใช้ Quintic Trajectory แล้ว ซึ่งจากกราฟที่ให้มาจะเห็นได้ว่าภาพที่ 2 และ ภาพที่ 3 ไม่มีความแตกต่างกัน เนื่องจากการ plot กราฟตำแหน่งใน 3 มิติ ในระยะห่างจุดที่ไม่มาก ทำให้ไม่สามารถเห็นได้ว่าการ plot เส้นทางการเคลื่อนที่ปกติและแบบใช้ quintic trajectory แล้วแตกต่างกัน จึงทำให้กราฟภาพที่ และ 3 มีความเหมือนกันมาก และสุดท้ายภาพที่ 4 คือตำแหน่งที่ปลาย end effector ขยับไป ซึ่งจะเห็นได้ว่าตำแหน่งทมี่ end effector ขยับไปจริง มีความถี่มากกว่า เนื่องจากเป็นการ plot จุดทุกจุดที่ end effector เคลื่อนที่ไป
# รูป
จากนั้นเมื่อนำมา plot เป็น animation การเคลื่อนที่ โดยให้จุดสีแดงเป็นตำแหน่งที่ End Effector เคลื่อนที่ไป จะทำให้เห็นพฤติกรรมการเคลื่อนที่ขึ้น โดยในช่วงแรกจะมีการเคลื่อนที่ในแนวแกน Y มาก และต่อมาค่อยทำตามรูปสี่เหลี่ยมแต่ละ Layer และในตอนจบจะเห็นได้ว่ามีการเคลื่อนที่ทั้งในแนวแกน X และแกน Y มากเช่นกัน
# คลิป
### 4.2 Posiotion & Velocity & Accerelation 
หลังจากที่ได้ใช้ Quintic Trajectory เนื่องจากต้องการให้ความเร็ว และความเร่งมีความต่อเนื่องกัน จึงนำมา plot เป็นกราฟที่แสดงแต่ละแกนใน 2 มิติดู จะเห็นได้ว่าตำแหน่งที่ได้เปลี่ยนแปลงตามจุดที่ได้จาก G-code ทั้งในแนวแกน x,y,z มุมของข้อต่อ 
# รูป ใหญ่
# รูป ซูม
จากกราฟจะเห็นได้ว่า ความเร็ว และความเร่งในการเคลื่อนทีมีความต่อเนื่องกัน แต่มีส่วนแรกที่ต้องเคลื่อนที่ในแกน y มากทำให้เกิดความแตกต่างของกราฟความเร็วมาก แต่เมื่อซูมเข้าไปดูจะเห็นได้ว่ากราฟยังมีความต่อเนื่องกันอยู่


### 4.3 Inverse Kinematics
เมื่อนำค่าตำแหน่งที่ได้มาคำนวณ Invese Kinematics แล้วทำให้ได้ค่าตำแหน่งองศาของ Scara robot ทีเปลี่ยนแปลงไปตามตำแหน่งของปลาย End effedtor ที่เคลื่อนที่ไป
# รูป
จากกราฟจะเห็นได้ว่า q1 มีค่าเริ่มต้นที่ประมาณ 0 องศา และเพิ่มขึ้นอย่างรวดเร็วในช่วงแรก จากนั้นลดลงกลับไปใกล้ค่าเริ่มต้นและมีการเปลี่ยนแปลงเล็กน้อยจนถึงช่วงท้ายของกราฟ ซึ่งมุมเพิ่มขึ้นอย่างรวดเร็วอีกครั้ง มุม q2 เริ่มต้นใกล้กับค่า 80 องศา มีการลดลงเล็กน้อยในช่วงต้น จากนั้นมีการเปลี่ยนแปลงเพียงเล็กน้อย และตอนท้ายมีค่าที่ลดลงแต่เพิ่มขึ้นอย่างรวดเร็วเมื่อเทียบกับภาพรวมกราฟ ข้อต่อ q3 มีลักษณะการเปลี่ยนแปลงแบบขั้นบันได โดยเริ่มต้นที่ค่าใกล้กับ 0 มิลลิเมตร และเพิ่มขึ้นทีละขั้นในช่วงเวลาที่กำหนด 

### 4.4 Dynamic Calculation
เมื่อนำค่าที่ได้จากการคำนวณ และการตั้งค่าต่าง ๆ ใน Solidwork มาทำการคำนวณตามสมการ Dynamic ทำให้ได้ค่า Torque ของแต่ละ Joint ออกมา ซึ่งเมื่อนำมา plot กราฟเพื่อดูความสัมพันธ์แล้วจะได้ว่า
# รูป
สำหรับกราฟแรงบิดของ q1 (กราฟด้านบน) แรงบิดเริ่มต้นด้วยค่าที่ค่อนข้างต่ำและคงที่ในช่วงแรกของเวลา หลังจากนั้นในช่วงกลางของกราฟ ค่าแรงบิดเพิ่มขึ้นและคงที่อยู่ที่ประมาณ 100 นิวตันเมตร ซึ่งแปลว่าข้อต่อนี้ทำงานได้อย่างปกติและเสถียรในช่วงเวลานี้ แต่ในช่วงท้ายของเวลา (ประมาณ 250-300 วินาที) ค่าแรงบิดกลับลดลงอย่างรวดเร็วและมีค่าเป็นลบ ซึ่งเกิดจากการหมุนกลับทิศของข้อต่อ 

ในส่วนของกราฟแรงบิดของ q2 (กราฟด้านล่าง) เริ่มต้นด้วยค่าแรงบิดใกล้ศูนย์ในช่วงแรกของเวลา ช่วงกลางของกราฟ แรงบิดคงที่อยู่ที่ประมาณ 50 นิวตันเมตร ซึ่งแสดงถึงการทำงานที่ปกติและเสถียรเหมือนกัน แต่ในช่วงท้ายของเวลา แรงบิดเพิ่มขึ้นอย่างรวดเร็วและพุ่งสูงเกิน 300 นิวตันเมตร ซึ่งสอดคล้องกับตำแหน่งที่ End effector เคลื่อนที่ไป โดยจะมีการเปลี่ยนแปลงมากในช่วงแรกและช่วงท้าย
### 4.5 Dynamic Model
ในการทำ Dynamic Simulation ด้วย Matlab ทำให้เห็นว่าหุ่นยนต์มีการเคลื่อนที่อย่างไรอย่างชัดเจน โดยเมื่อดูเทียบกันแล้ว Torque ที่เปลี่ยนแปลงไปมีความสอดคล้องกับตำแหน่งของหุ่นยนต์ที่เคลื่อนที่อยู่ โดยเมื่อเกิดการเปลี่ยนแปลงตำแหน่งที่มากทำให้เกิด Torque มาก
# กราฟ
# คลิป

จากนั้้นเพื่อทำการตรวจสอบว่าหุ่นยนต์มีการเคลื่อนที่ที่ถูกต้องไหม 
## บทที่ 5 สรุปผล และวิเคราะห์ผล

### สรุปผลการศึกษา

จากการนำไฟล์ G-code ที่สร้างจากโมเดล CAD ของชิ้นงานมาทำการอ่านและแยกจุด (Waypoints) ตามแต่ละ Layer ของการพิมพ์ 3 มิติ สามารถนำมาวางแผนเส้นทางโดยใช้ Path Planning ในการเชื่อมจุดแต่ละจุดเข้าด้วยกัน รวมทั้งใช้ Quintic Trajectory เพื่อกำหนดให้ความเร็วและความเร่งในการเคลื่อนที่เปลี่ยนแปลงอย่างราบรื่น และต่อเนื่องมากขึ้นเมื่อเปรียบเทียบกับการเคลื่อนที่ที่เกิดจากการเชื่อมต่อจุดโดยตรง ทำให้ได้เส้นทางการเคลื่อนที่ของปลายหัวพิมพ์ (End Effector) ที่มีความต่อเนื่องในด้านความเร็วและความเร่ง จึงทำให้การควบคุมการเคลื่อนที่ของแขนกลเป็นไปอย่างมีประสิทธิภาพ ลดการกระชากและการสั่นสะเทือน

จากนั้นได้ทำการหา MDH-parameter ของ SCARA robot เพื่อกำหนดระบบพิกัดอ้างอิงของแต่ละ Link และ Joint และทำการคำนวณ Invese Kinematics เพื่อคำนวณหามุมข้อต่อจากตำแหน่งปลายที่ต้องการซึ่งสามารถหามุมข้อต่อของแขนกล SCARA ตามจุดต่าง ๆ ที่ได้จาก Trajectory Planning ได้ จากนั้นทำการวิเคราะห์ทาง Dynamics ของแขน SCARA โดยใช้สมการ Lagrange-Euler และพิจารณาค่ามวล โมเมนต์ความเฉื่อย รวมทั้งนำค่ามุม ความเร็วเชิงมุม และความเร่งเชิงมุมที่ได้จาก Invese Kinematics และ Trajectory Planner มาคำนวณ Torque ผลการคำนวณแสดงให้เห็นว่าเมื่อมีการเคลื่อนที่ตามเส้นทางที่ซับซ้อนหรือมีการเปลี่ยนทิศทางและความเร็วมากขึ้น แรงบิดก็จะเพิ่มสูงขึ้นตาม ซึ่งช่วยให้ผู้ออกแบบสามารถใช้ข้อมูลนี้ในการเลือกมอเตอร์และกำหนดกลยุทธ์การควบคุมที่เหมาะสม จากนั้นได้ลองนำค่าตำแหน่งองศาที่ได้มาสร้างแบบจำลองและแสดงผลการเคลื่อนที่ของแขนกล SCARA ทั้งในมิติของตำแหน่ง เวลา และยังแสดงผลกราฟความเร็ว ความเร่ง และแรงบิดของข้อต่อใน MATLAB ช่วยให้สามารถวิเคราะห์พฤติกรรมของแขนกลได้อย่างชัดเจน สามารถปรับปรุงการเคลื่อนที่ได้ง่ายขึ้นก่อนนำไปใช้งานกับหุ่นยนต์จริง

### วิเคราะห์ผล

- การนำ G-code มาใช้เป็น Input ทำให้เส้นทางการพิมพ์ชิ้นงานของ 3D Printer สามารถแปลงเป็นข้อมูลตำแหน่ง (X, Y, Z) ของหัวพิมพ์แขนกล SCARA ได้โดยตรง ช่วยให้เห็นภาพการเคลื่อนที่ของหัวพิมพ์ได้ง่ายมากขึ้น 
- จากการใช้ Quintic Trajectory Planner พบว่าสามารถสร้างเส้นทางการเคลื่อนที่ที่ราบรื่น ช่วยลดการกระชากของระบบ และส่งผลดีต่อความแม่นยำของการพิมพ์ชิ้นงาน เนื่องจากหัวพิมพ์สามารถเคลื่อนที่ด้วยความเร็วและความเร่งที่มีความต่อเนื่อง
- ข้อมูลค่าแรงบิดที่คำนวณได้แสดงให้เห็นความสัมพันธ์ระหว่างพฤติกรรมการเคลื่อนที่ของแขนกลกับภาระงานที่ข้อต่อต้องรับ เมื่อแขนกลเคลื่อนที่ไปยังตำแหน่งที่ห่างไกลหรือเปลี่ยนทิศทางอย่างรวดเร็ว แรงบิดก็มีค่าสูงขึ้นตามไปด้วย ซึงมีประโยชน์อย่างยิ่งในการเลือกมอเตอร์ กำหนดเกียร์ หรือพิจารณาความแข็งแรงของโครงสร้างแขนกล เพื่อให้หุ่นยนต์ทำงานได้ภายใต้เงื่อนไขที่ต้องการ
